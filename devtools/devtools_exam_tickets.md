#### 1.1. Сравнительный анализ текстового и бинарного форматов.
Преимущества простого текста
* Воспринимаемость человеком — просто понять структуру и содержание,\ часто без документации и специальных инструментальных средств.
* Простота — формат крайне удобен и его можно редактировать огромным количеством инструментов. И в первую очередь простым текстовым редактором.
* Версионируемость — файлы легко сравнивать, находить изменения.
* Переносимость — текстовый файл может быть прочитан на любой системе или ОС.
* Устойчивость — каждое слово и символ в таком файле самодостаточны и, если случится повреждение байтов в таком файле, то обычно можно восстановить данные или продолжить обработку остального содержимого.

Преимущества бинарного формата
* Минимальный размер — не содержат "разметки", часто являются сжатыми.
* Машинное представление данных, иногда допускает прямую (а значит быструю) загрузку в оперативную память (например сериализованные структуры данных). Нет необходимости в конверсии.
* Эффективность некоторых операций: поиск элементов, иногда вставка и удаление.

#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.
Ручное тестирование
* Ключевые термины
 * Тест — проверка, осуществляемая "руками"
 * Тест-план — документ со списком проверок
 * Отдел тестирования (QA)
*	Профессия ручного тестировщика вырождается!
 * За качество ответственность несут разработчики (пишут тесты!)
 * Google: Software Engineer in Test
*	Ручное тестирование используется для:
 * Тестирования GUI и UX (удобства использования)
 * Бета-тестирование с реальными пользователями

Автоматические тесты
* Тест — это "обычная" функция, реализующая некоторый сценарий использования программных сущностей.
* Тестовая сборка (test suite) — приложение с тестами, обычно консольное.

Необходимость автоматических тестов
**Тест пишется один раз, а запускается десятки тысяч раз!**
*	Развитие системы
*	Коллективное владение
*	Работа с legacy-кодом (сторонние контрибуции)
*	Портирование ПО на новые платформы
*	Тестирование новых платформ

Современная стратегия тестирования
*	Без "зеленых" тестов нет уверенности в работоспособности кода
*	Фокус на максимальную автоматизацию
 *	Полное тестирование требуется несколько раз в день, каждому члену команды
*	Тесты пишутся самими разработчиками, одновременно с реализацией
 *	Тесты это лучшая документация, которая всегда актуальна (компилятор!)
 *	Тесты это первые сэмплы, показывающие простые примеры использования
 *	Test-Driven Development
*	Код тестируется непрерывно
 *	Это делается локально на машине разработчика
 *	Это делается на сервере до того, как добавить его в репозиторий

Современная стратегия тестирования (2)
*	Автоматические тесты замещают отладку
 *	Предсказуемость времени разработки
 *	Пойманный баг документируется в виде теста
*	Тесты — это "first-class citizens"
 *	Стоит отдавать код вместе с тестами
 *	Нужно заботиться о качестве кода тестов
 *	Метафора тестов: скелет, позволяющий организму двигаться

Классификация тестов: по масштабу
*	Модульные (Unit)
*	Интеграционные
 *	Инфраструктурные
*	Системные
*	Приемочные (acceptance), функциональные

Классификация тестов: по назначению
*	Функциональные требования
 *	На задымление (smoke)
 *	Регрессионные (regression)
 *	На точность (accuracy)
 *	Соответствие/совместимость (conformance/compliance)
 *	Приемочные (acceptance)
 *	Функциональные (functional)
*	Нефункциональные требования
 *	На производительность (performance)
 *	Стресс (stress)
 *	Нагрузочные (load)
 *	Качество кода (code quality)

Критерии хорошего теста
1.	Короткий (имеет чистый код)
2.	Сфокусированный (только один assert)
3.	Быстрый
4.	Автоматический
5.	Независим от порядка исполнения и окружения
Паттерн AAA: Arrange, Act, Assert

Инструментарий
*	JUnit — тестирование приложений для Java
*	TestNG — тестирование приложений для Java
*	NUnit — порт JUnit под .NET
*	Selenium — тестирование приложений HTML;
*	TOSCA Testsuite — тестирование приложений HTML, .NET, Java, SAP
*	UniTESK — тестирование приложений на Java, Си.
	
#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.

* TXT: 
1. Документация (README, Changelog, TODO)
2. Логи (Отладочная информация, coredump)
3. Консольный вывод утилит (Разнообразные анализаторы)
  Плюсы:
 * Понятны человеку в своем исходном виде
 * Версионируемость
 * Кроссплатформенность
 * Имеют упрощенный синтаксис
 * Понятны человеку в своем исходном виде

  Минусы:
 * хз

* XML: 
1. Отчеты различных утилит (Результаты тестирования)
2. Сериализация структур данных (Представление)
3. Конфигурационные файлы( В том числе для построения)
Плюсы:
 * хз

  Минусы:
 * хз

* YAML: 
1. Конфигурационные файлы
2. Сериализованные данные
   Плюсы:
 * хз
   Минусы:
 * хз

* JSON:   
1. Сериализация структур, чаще всего в веб-приложениях(Является подмножеством YAML)
   Плюсы:
 * хз

   Минусы:
 * хз 

**Текст как исходник**
1. Все языки программирования используют текстовый формат как исходный. В том числе и ассемблер.
2. А некоторые языки, и как конечный формат распространения:
 * Скриптовые языки: bash, CMD
 * Динамические языки: Python, Perl, Ruby
 * Другие: JavaScript, MATLAB, GLSL, OpenCL (< v1.2?), CMake

Открытость исходника позволяет:
 * Читать и изучать
 * Модифицировать и переиспользовать
 * Генерировать

#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

Google Test
1. Популярный фреймворк для написания модульных тестов на С++,\ разработанный Google.
2. Open-source проект c BSD-лицензией\ (допускает использование в закрытых коммерческих проектах).
3. Используется в целом ряде крупных проектов
 * Chromium, LLVM компилятор, OpenCV
4. Написан на C++, строится при помощи CMake
 * Поддерживает: Linux, Mac OS X, Windows, Cygwin, Windows CE и Symbian
5. Как правило используется в консольном режиме, но существует вспомогательное GUI приложение.

Возможности Google Test
* Automatic test discovery
* Rich set of assertions, user-defined assertions
* Death tests
* Fatal and non-fatal failures
* Value- and type-parameterized tests
* Various options for running the tests
* XML test report generation

Базовые концепции

![](resources/gtest_concepts.png)

* Каждый тест реализован как функция, с использованием макроса TEST() или TEST_F().
* TEST() не только определяет, но и "регистрирует" тест.

Полезные советы
* Тесты можно временно выключать
* Тесты можно фильтровать по имени при запуске
* У Google Test есть ряд других полезных опций

Приложение: Порядок использования Google Test

* Начальная стадия

1. Скомпилировать Google Test в библиотеку.
2. Создать новое консольное приложение (test suite)\ и прилинковать к нему библиотеку Google Test.
3. Добавить тесты.
4. Скомпилировать приложение с тестами и запустить его.

* Основная стадия

1. Новые тесты добавляются в тот же test suite, их могут быть тысячи.
2. При необходимости test suite разбивается на несколько
3. Корректность и производительность
4. Быстрый (pre-commit) и полный (ночной)

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.

Инструменты командной строки
1. Просмотр
 * cat/tac, head/tail, less
2. Поиск
 * grep
3. Обработка
 * sed, awk

Преимущества:
1. Удобство
2. Возможность работы со скрытыми функциями

Недостатки:
1. Необходимо знание команд

**Grep examples**

Многоцелевая поисковая утилита, использующая регулярные выражения. Изначально это была команда в древнем строчном редакторе ed, g/re/p, что означает -- global - regular expression - print.

       grep pattern [file...]

Поиск участков текста в файле(ах), соответствующих шаблону pattern, где pattern может быть как обычной строкой, так и регулярным выражением.
 * grep -nIHR "^#" --include=*.md ./
  * Вывод всех заголовков в Markdown файлах ("| wc -l" добавит их подсчет)
 * grep -nIHR "class.*Matcher" --include=*.hpp -B1 ./
  * Печать деклараций всех классов, содержащих слово Matcher (+одна строка до)

**Sed examples**
Неинтерактивный "потоковый редактор". Широко используется в сценариях на языке командной оболочки.
Stream editor

* sed 's/foo/bar/g' — заменяет foo на bar
* sed '/baz/s/foo/bar/g' — то же самое, но если строка содержит baz
* sed 's/[ \t]*$//' — удалить "висячие" пробельные символы
* sed '/regex/G' — вставить пустую строку под каждой, содержащей "regex"
* sed 'n;n;n;n;G;' — вставить пустую строку через каждые 5
* sed -n '$=' — посчитать количество строк
* sed '1,10d' — удалить первые 10 строк файла

**Awk examples**
Утилита контекстного поиска и преобразования текста, замечательный инструмент для извлечения и/или обработки полей (колонок) в структурированных текстовых файлах. Синтаксис awk напоминает язык C.
                 
    awk — pattern-directed scanning and processing language
Authors: Aho, Weinberger, Kernighan

Примеры:

* awk '{print NR "\t" $0}' — распечатать файл с номерами строк
* awk 'END{print NR}' — вывести число строк в файле
* awk '{print $2, $1}' — распечатать второе и первое поле в обратном порядке
* awk '{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}' — вывести сумму полей для * каждой строки
* awk '{sub(/[ \t]+$/, "")};1' — удалить "висячие" пробельные символы
* awk '{l=length();s=int((79-l)/2); printf "%"(s+l)"s\n",$0}' filename — центрировать и распечатать файл

#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

Непрерывная интеграция (англ. Continuous Integration) — это практика разработки ПО, которая заключается в выполнении частых автоматизированных сборок проекта для скорейшего выявления и решения интеграционных проблем.
Непрерывная сборка — это сердцебиение вашего проекта.

**Эволюция взглядов на интеграцию**

Можно условно представить в виде следующих практик:
1. Waterfall: разделить на компоненты, реализовать, интеграция — отдельная фаза
2. Nightly build: интегрироваться часто, ночной билд (heartbeet of the project)
3. Continuous Integration: интегрироваться непрерывно, тестирование каждого вливания
4. Pre-commit Testing: интегрироваться непрерывно, но после проверки стабильности
5. Continuous Deployment: развертываться непрерывно, сразу после проверки стабильности

На GitHub механизмом pull request реализуется Pre-Commit Testing

**Реализация**
Задачи выделенного сервера
1. Получение исходного кода из репозитория
2. Сборка проекта (в том числе построение дистрибутивов)
3. Выполнение тестов и автоматических проверок
4. Отправка отчетов (хранение истории и статистики)
5. Развёртывание готового проекта

**Преимущества**
Автоматические проверки: Статический анализ
1. Проверки на корректность
 * Максимальный уровень предупреждений компилятора (нескольких компиляторов!)
 * Автоматический поиск ошибок (PVS-Studio, cppcheck, Coverity Scan)
 * Соответстиве стандартам (стандарт ASIL - инструмент LDRA)
2. Стиль кодирования (lint, vera++, cpplint.py)
 * Чистый код (именование, форматирование)
 * Анализ сложности кода
3. Специальные инструменты
 * ABI compliance checker
 * Поиск IP проблем, например GPL кода ()

Автоматические проверки: Динамический анализ
1. Анализ покрытия кода тестами (gcov, BullseyeCoverage)
2. Утечки памяти, гонки данных (Valgrind, BoundsChecker)
3. Анализ производительности (GoogleTest)
4. Intel Parallel Studio

Примеры систем
1. Hudson > Jenkins
2. CruiseControl (CruiseControl.NET), TeamCity
3. Travis CI, AppVeyor, [Drone.IO][https://drone.io]
4. BuildBot

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

#### 5.1. СКВ. Основные функции и термины, базовые принципы.
#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

Git Flow:
![](resources/git-flow.png)

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.
#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.
#### 8.2. ИСР. Назначение, состав, возможности.

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.
#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#### 10.2. UNIX. Философия и преимущества при автоматизации.

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).
#### 12.2. CMake. Назначение, возможности, плюсы и минусы.

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).
#### 13.2. Метапрограммирование. Определение и примеры.

#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.






