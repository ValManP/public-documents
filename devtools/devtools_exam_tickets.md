#### 1.1. Сравнительный анализ текстового и бинарного форматов.
#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.

#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.
#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.
#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

#### 5.1. СКВ. Основные функции и термины, базовые принципы.
#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

>**API (Application Programming Interface)** - набор готовых классов, процедур, функций, структур и констант, предоставляемых ОС, приложением, библиотекой для использования во внешних программных продуктах.

- Все современные ОС предоставляют API;
- Все прикладные приложения явно или косвенно от него зависят;
- Необходимо поддерживать совместимость.

**Совместимости:**

- **Бинарная** - совместимость на уровне бинарных интерфейсов (ABI). Модуль можно заменить другим без потерь.
- **На уровне исходных кодов** (API, source). Замена библиотеки на другую не ломает компиляцию и логику программы.

**Способы реализации API:**
- Программные прерывания процессора;
- Динамическая компоновка и вызов библиотечных функции;
- Формирование пакетов данных соответствующих общим соглашениям.

**Бинарная совместимость в С++:**

1. Совпадают сигнатуры всех функций и методов;
2. Совпадает sizeof для всех экспортируемых объектов;
3. Совпадает состав всех структур, в том числе выравнивание;
4. Совпадают значения параметров по умолчанию;
5. Совпадают виртуальные методы, не добавляется новых виртуальных методов;
6. Совпадает иерархия виртуального наследования;
7. Могут отличаться имена констант, если они не экспортируются из библиотеки как символ;
8. Могут отличаться имена и структура макросов;
9. Могут быть добавлены новые невиртуальные методы;
10. Могут быть добавлены перегрузки функций, если функция уже была перегружена.

**Совместимость на уровне исходного кода в C++:**

1. Может отличаться число параметров функции, если определены значения по умолчанию для новых параметров;
2. Могут быть добавлены перегрузки методов;
3. Могут отличаться виртуальные методы;
4. Могут отличаться sizeof, выравнивание и поля структур;
5. Совпадают имена всех констант и макросов.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

**Назначение:**

Git - распределенная СКВ (DVCS). Каждый имеет у себя локальную копию репозитария с сервера.

- Разработан Линусом Торвальдсом для работы над ядром Linux в 2005 году.
- В настоящее время поддерживается Джунио Хамано, сотрудником Google.
- Не очень прост в освоении, однако очень быстрый и функциональный.
- Имеет наиболее "сильное" сообщество, инструментальную поддержку.

**Преимущества:**

- Распределенная СКВ - можно коммитить столь часто, сколь угодно, даже если в данный момент отсутствует соединение с сервером.
- Работа с несколькими ветками.
- Удобный механизм слияния (merge).

**Интерфейс:**

![](resources/git-cheat-sheet.png)

**GutHub Flow:**

Anything in the `master` branch is deployable.

1. Create branch
  - To work on something new, create a descriptively named branch off of `master` (ie: `new-oauth2-scopes`).
2. Develop in branch
  - Commit to that branch locally and regularly push your work to the same named branch on the server.
3. Open a pull request (ask for review)
  - When you need feedback or help, or you think the branch is ready for merging, open a pull request.
4. Merge after review
  - After someone else has reviewed and signed off on the feature, you can merge it into `master`.
5. Deploy
  - Once it is merged and pushed to `master`, you can and *should* deploy immediately.

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

>**Исполняемый модуль** — файл, содержащий программу в виде, в котором она может быть (после загрузки в память и настройки по месту) исполнена вычислительной машиной.

**ELF модуль на UNIX (1)**

![](./resources/Elf-layout.png)

**ELF модуль на UNIX (2)**

1. Заголовок файла:
  - Архитектура аппаратной платформы;
  - Аппаратно зависимые флаги;
  - Точка входа
2. Таблица заголовков сегментов;
3. Таблица заголовков секций;
4. Данные сегментов и секций.

**ELF модуль на UNIX (3)**

**Сегмент** - это непрерывная область адресного пространства со своими
атрибутами доступа. В частности, сегмент кода имеет атрибут исполнения, а
сегмент данных — атрибуты чтения и записи.

**Секция** - фрагмент сегмента, имеющий определённое назначение:

- .init (процедуры инициализации);
- .plt (секция связок);
- .text (основой код программы);
- .fini (процедуры финализации).

Информация о сегментах используется при выполнении (Run-time).
Информация о секциях используются при динамической компоновке (Link-time).
Исполняемые файлы, `*.so`, `*.a`, `*.o` файлы используют ELF формат.

**PE Модуль на Windows (1)**

![](./resources/Pe-layout.png)

**PE Модуль на Windows (2)**

PE = Portable Executable

1. MS DOS часть для совместимости;
2. PE заголовок
  - Архитектура аппаратной платформы;
  - Аппаратно зависимые флаги;
  - Подсистема Windows (GUI, CUI, OS/2, Posix);
  - Точка входа;
  - Контрольная сумма;
3. Заголовки секций;
4. Данные секций.

**PE Модуль на Windows (3)**

- Исполняемые файлы `*.exe`, динамические библиотеки `*.dll` и драйверы используют
   PE формат;
- Формат несколько раз расширялся и некоторые функции могут быть реализованы
   по-разному;
- Не все инструменты одинаково интерпретируют/генерируют PE файлы;
- В PE  модуле есть отдельная секция ресурсов.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.

**Преимущества:**

- Мощность / повышение уровня абстракции
  - Фокус на основной задаче
  - Меньшее количество переключений контекста
- Надежность
  - Отсутствие человеческого фактора
- Скорость
- Дешевизна
  - Особенно при многократном запуске
- Освобождение времени

**Типичные классы задач на автоматизацию (в работе программиста):**
- Слепая печать
- Сбор и обработка данных
  - Составление отчетов/графиков, анализ и обработка больших массивов данных
- Тестирование
  - Изменения ничего не сломали, анализ производительности
- Администрирование
  - Регулярные процедуры (бэкап), сложное конфигурирование
- Собственно, автоматизация
  - Построение дистрибутивов, развертывание

#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

- **Отладка** - это процесс нахождения и устранения ошибок и дефектов в компьютерной программе или в электронном оборудовании.
- **Отладчик** - это компьютерная программа, которая используется для тестирования и отладки других программ.

**Общие определения:**

- **Breakpoint** (точка останова) - это преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика.
- **Watchpoint** - точка останова по данным. Срабатывает, когда меняется значение заданного выражения или переменной.
- **Catchpoint** - специальная точка останова, которая срабатывает при достижении специального события, например, C++ исключения или загрузки библиотеки.
- **Call stack** (стек вызовов) - хранит информацию об активных процедурах и функциях.

**Распространенные техники отладки**:

- Printf отладка, трассирование и логирование
- Post-mortem отладка (дамп памяти, логи)
- Использование специальных программ (отладчиков)
- Проверка различных утверждений в коде (assert)
- Алгоритм "волчья ограда"

**Edward Gauss - "Wolf fence" algorithm:**

"There's one wolf in Alaska, how do you find it? First build a fence down the middle of the state, wait for the wolf to howl, determine which side of the fence it is on. Repeat process on that side only, until you get to the point where you can see the wolf)."
In other words: put in a few "print" statements until you find the statement that is failing (then maybe work backwords from the "tracks" to find out where the wolf/bug comes from).

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.

**Назначение:**

- Это язык разметки текстовой информации
- Имеет упрощенный синтаксис
- Ориентирован для редактирования из простого текстового редактора
- Понятен человеку в своем исходном виде

**Синтаксис:**

![](resources/markdown-cheat-sheet.jpg)

**Примеры использования:**

- GitHub: wiki and comments using GFM.
- StackOverflow: questions and answers editing.
- Askbot: the same as StackOverflow.
- Создание книг.
- Создание презентаций.
- Создание статических сайтов.

**Особенности использования:**

- Вероятно, самый популярный из легковесных языков разметки на сегодняшний день.
- Используется на StackOverflow и GitHub в качестве языка для wiki и комментариев.
- Поддерживается редакторами, оброс большим количеством инструментов.
- Минус: встречаются расхождения в "толковании". Но уже есть CommonMark!

#### 8.2. ИСР. Назначение, состав, возможности.

>**Интегрированная среда разработки**, ИСР (англ. IDE, Integrated development environment или integrated debugging environment) — система программных средств, используемая программистами для разработки программного обеспечения.

**Отличия ИСР от редакторов исходного кода:**

- Наличие компилятора 
- Анализ кода 
- Средства автоматизации сборки 
- Наличие отладчика 
- Наличие средств интеграции с СКВ 
- Браузер классов 
- Диаграмма иерархии классов 
- Инспектор объектов

**Основные функции/возможности современных ИСР:**

- Автодополнение кода
- Поддержка шаблонов проектов
- Сниппеты
- Поддержка систем контроля версий
- Интеграция задач (//TODO: ...)
- Браузер классов
- Визульное редактирование классов
- Инструменты рефакторинга
- Профилировщик
- Работа с СУБД, веб-сервисами

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.

**Важные свойства редакторов:**

- Кросс-платформенность
- Настраиваемость
  - Шрифты, оформление, клавиатурные комбинации
- Расширяемость
  - Новые языки программирования и форматы файлов
- Программируемость
  - Программируемость сложных операций (макросы, сценарии)
- Скорость работы

**Возможности:**

- Навигация
  - По файлам
    - Перебор закладок
    - Боковая панель
    - Go to anything
  - Внутри файлов
    - Хождение по словам, строкам, экрану
    - Переход на строку
    - Переход между скобками
   - Go to symbol
- Выделение
  - Слов, Строк
  - Абзацев
  - Выражений внутри скобок
  - Всех вхождений слова => Поиск
- Поиск
  - Простой поиск
    - Multiple cursor
    - Регулярные выражения
  - Инкрементальный
  - Быстрый
- Редактирование
  - Комментирование
  - Перестановка двух символов
  - Удаление: слов, строк, окончаний строк
  - Манипуляции со строками
    - Дублирование, переупорядочение, сортировка
    - Слияние и автоматический перенос
  - Редактирование нескольких строк и прямоугольных регионов
- Продвинутые возможности
  - Package Control
  - Snippets
  - Vintage Mode
  - Custom Builds
  - Projects

**Vim** - свободный текстовый редактор, созданный на базе vi. Один из культовых редакторов. Один из мощнейших редакторов с полной свободой настройки и автоматизации. Имеет огромное количество расширений (более 3000). Используется практически в любых проектах.

**Примеры команд:**

- `5D`, `Y5p` - удалить/повторить строку 5 раз
- `/^joe` - найти все строки, начинающиеся с joe
- `:g!/REGEXP/d` - удалить все строки, не содержащие REGEXP
- `:%norm jdd` - удалить каждую вторую строку
- `ci(`, `ci[` - удалить содержимое внутри скобок
- `guu`, `gUU` - перевести всю строку в нижний/верхний регистр

**Emacs** - семейство расширяемых многофункциональных текстовых редакторов. Второй культовый редактор. Возможно, еще более мощный редактор, чем Vim (Emacs as OS). Имеет более 2000 встроенных команд, позволяет комбинировать их в макросы.

**Идеология Emacs:**
- "Всё в одном"
  - Функциональность: базовая, основной режим, дополнительные режимы
- Расширяемость
  - Программируется на Elisp, имеются пакеты расширений, клавиатурные комбинации
- Настраиваемость под пользователя
  - Elisp-переменные, определение функций, создание hook'ов
- Документированность
  - Подробная документация, вплоть до функций и переменных

**Sublime Text** - кроссплатформенный редактор текста и кода. Имеет Python API, существует большое количество раширений. Не является свободным, однако почти все расширения открыты. Становится все более популярным.

Самый информативный - Vim (куча окошечек: несколько окон с исходным кодом, структура проекта, СКВ история, браузер классов, все открыто сразу).
Самый каноничный и олдскульный - Emacs.
Sublime Text - как Vim, только с интерфейсом, похожим на студию.

#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

- **Отладка** - это процесс нахождения и устранения ошибок и дефектов в компьютерной программе или в электронном оборудовании.
- **Отладчик** - это компьютерная программа, которая используется для тестирования и отладки других программ.

**Общие определения:**

- **Breakpoint** (точка останова) - это преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика.
  **Примеры команд для GDB:** break, rbreak, tbreak
- **Watchpoint** - точка останова по данным. Срабатывает, когда меняется значение заданного выражения или переменной.
  **Примеры команд для GDB:** watch, rwatch, awatch
- **Catchpoint** - специальная точка останова, которая срабатывает при достижении специального события, например, C++ исключения или загрузки библиотеки.
- **Call stack** (стек вызовов) - хранит информацию об активных процедурах и функциях.
  **Примеры команд для GDB:** catch throw, catch catch, catch syscall, catch load.

**Распространенные техники отладки**:

- Printf отладка, трассирование и логирование
- Post-mortem отладка (дамп памяти, логи)
- Использование специальных программ (отладчиков)
- Проверка различных утверждений в коде (assert)
- Алгоритм "волчья ограда"

**Отладочная информация:**

Любой компилятор по умолчанию снабжает объектный файл отладочной информацией. Вся эта отладочная информация предназначается для отладки программы отладчиком. Отладочная информация может значительно увеличить объем файла (в 3-4 раза). Для создания программ "релизов" существует отдельная программа, позволяющая удалить отладочную информацию из запускаемого файла (например, strip).

**Полезные опции для GCC компилятора:**

- **`-g<level>`** - отладочная информация в нативном формате для операционной системы
  - level = 0 - нет отладочной информации
  - level = 1 - минимально необходимая информация
  - level = 3 - дополнительная информация
- **`-ggdb<level>`** - информация в формате GDB
- **`-O0`** - отключение всех оптимизаций компилятора
- **`-fno-omit-frame-pointer`** - использовать указатель на фрейм

**Запуск программ из под GDB:**

- **`$ gdb --args <программа с аргументами>`**
- **`$ gdb <программа> [<pid>] [<core-файл>]`**
- **`r, run [аргументы]`** - запуск программы под GDB
- **`start [аргументы]`** - удобный способ запуска программы с точкой останова на первой строчке функции `main`
- **`attach <pid> / detach`** - отладка уже запущенного процесса

**Продолжение и пошаговое исполнение:**

- **`continue, c, fg`** - возобновление исполнения программы
- **`s, step [count]`** - продолжить исполнение до следующей строчки исходного кода
- **`n, next [count]`** - продолжить исполнение до следующей строчки исходного кода в текущем фрейме
- **`ni, nexti, si, stepi [count]`** - так же как `next` и `step`, но для инструкции
- **`fin, finish`** - продолжить исполнение до тех пор, пока текущая функция не завершится
- **`u, until [location]`** - продолжить исполнение до тех пор, пока не достигнута следующая строчка

**Вывод информации о стеке вызовов:**

- **`bt, backtrace [full] [n]`** - напечатать стек вызовов
- **`frame [n]`** - навигация по текущему стеку вызовов
- **`info frame`** - вывести подробную информацию о текущем стековом фрейме
- **`info args`** - вывести аргументы для текущего фрейма
- **`info locals`** - вывести локальные переменные для текущего фрейма

**Просмотр данных:**

- **`print [/fmt] <expr>`** - показать значение выражения
  - a - указатель
  - x - шестнадцатеричное целое
  - s - трактовать как C-строку
  - u - беззнаковое целое
- **`print *address@<len>`** - показать массив
- **`display [/fmt] <expr>`** - показывать каждый раз
- **`delete/disable/enable display <id>`** - управлять списком для отображения данных
- **`info display`** - вывести список выражений для отображения
- **`info <registers | all-registers>`** - показать регистры

**Навигация по исходным файлам:**

- **`l, list [linenum | function | - | +]`** - показать код
- **`forward-search, search regexp`** - искать в прямом направлении в текущем файле
- **`reverse-search regexp`** - искать в обратном направлении в текущем файле
- **`dir, directory <dirname>`** - добавить директории для поиска файлов
- **`set substitute-path <to> <from>`** - определить подстановочное правило для директории
- **`disassemble [/m | /r] [start,+length]`** - показать диапазон памяти, как инструкции процессора

**Исполнение в обратном направлении:**

- **`record [full]`** - начать процесс записи
- **`record stop`** - остановить процесс записи
- **`reverse-continue, reverse-step, reverse-next, reverse-nexti,`**
  **`reverse-stepi, reverse-finish`** - команды для обратного исполнения программы
- **`checkpoint`** - сделать снимок состояния программы
- **`restart <checkpoint-id>`** - восстановить состояние
- **`info checkpoints`** - информация о всех checkpoints
- **`delete checkpoint <id>`** - удалить checkpoint

**Текстовый пользовательский интерфейс:**

- Запустить `gdb -tui` и **C-x C-a** сочетание клавиш
- В TUI режиме, gdb может отображать несколько окон:
  - command - GDB командная строка и вывод
  - source - показывает исходный код программы
  - assembly - показывает вывод дизассемблера
  - register - показывает регистры процессора
- `layout <prev | next | asm | src | split | regs>`
- `focus <prev | next | asm | src | split | regs | cmd>`
- `refresh` (или **C-L** сочетание клавиш)

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#####Shell-скрипт

Программа, выполняемая командной оболочкой операционной системы. Пишется скрипт, в котором указываются команды сборки файлов программы.

Плюсы:
- Не нужно компилировать
- Присутствует на различных платформах (Linux - .sh, Windows - .bat)
- Нужно знать только команды консоли

Минусы:
- Не запрограммируешь сложную логику сборки

#####Make (1977)

Утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка в исполняемые файлы или библиотеки.

Программа make выполняет команды согласно правилам, указанным в Makefile.

Синтаксис Makefile:
```
цель1 цель2 ...: реквизит1 реквизит2 ...
        команда1
        команда2
        ...
```

Пример Makefile:
```
program: main.o lib.o
        cc -o program main.o lib.o
```

#####Autotools

Это набор программных средств, предназначенных для поддержки переносимости исходного кода программ между UNIX-подобными системами. Включает в себя Autoconf, Automake и др.

- **Makefile.am** - Automake читает эти файлы и создает переносимый Makefile.am, которые после обработки скриптом конфигурации становится Makefile и используется make
- **Configure.ac** - Autoconf читает эти файлы и генерирует скрипт настройки configure. Скрипт запускается пользователем. Он читает файлы с расширением .in, обрабатывает их и в конечном результате получает Makefile.

Плюсы:
- Был де-факто стандартом и до сих пор используется

Минусы:
- Сложный
- Только Unix
- Зависимости

#####Cmake

Это кроссплатформенная система автоматизации сборки программного обеспечения из исходного кода. CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления сборкой из файлов CMakeLists.txt

Плюсы:
- Удобен после непродолжительного обучения
- Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или простой текстовый редактор)
- Обеспечивает переносимость и является стандартом де-факто для кроссплатформенных С++ проектов


Минусы:
- "Собственный" язык
- Поначалу кажется нетривиальным

-----
#####IDE

> __Интегрированная среда разработки, ИСР__ (англ. __IDE, Integrated development
> environment__ или __integrated debugging environment__) — система программных
> средств, используемая программистами для разработки программного обеспечения.

###### Функции современных IDE

  - Автодополнение кода
  - Поддержка шаблонов проектов
  - Сниппеты
  - Поддержка систем контроля версий
  - Интеграция задач (`//TODO: ...`)
  - Браузер классов
  - Визульное редактирование классов
  - Инструменты рефакторинга
  - Профилировщик
  - Работа с СУБД, веб-сервисами

#### 10.2. UNIX. Философия и преимущества при автоматизации.
This is the Unix philosophy:
- Write programs that do one thing and do it well.
- Write programs to work together.
- Write programs to handle text streams, because that is a universal interface.

#####Преимущества автоматизации
  - Мощность / повышение уровня абстракции
    - Фокус на основной задаче
    - Меньшее количество переключений контекста
  - Надежность
    - Отсутствие человеческого фактора
  - Скорость
  - Дешевизна
    - Особенно при многократном запуске
  - Освобождение времени

#####Классы задач на автоматизацию
  - Сбор и обработка данных
    - Составление отчетов/графиков, анализ и обработка больших массивов данных
  - Тестирование
    - Изменения ничего не сломали, анализ производительности
  - Администрирование
    - Регулярные процедуры (бэкап), сложное конфигурирование
  - Собственно автоматизация
    - Построение дистрибутивов, развертывание

#####Преимущества Unix при автоматизации
  - Огромное количество утилит на любой случай жизни
    - find, cron, tar, sed, etc.
  - Вместе со скриптовыми языками (Bash, Perl, Python, etc) предоставляет широчайшие возможности для автоматизации

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.

__Git commits__

![](resources/git-commits.png)

__Git branch__
Создать новую ветку с именем testing (указатель на коммит!):

    $ git branch testing

![](resources/git-branch-testing.png)

__Git checkout__
Извлечь состояние репозитория, соответствующее ветке `testing`:

    $ git checkout testing

![](resources/git-checkout.png)

__Merging__

![](resources/git-merge-after.png)

`С6` — это так называемый `merge commit`
Он основан не на каком-то патче, он указывает на состояние проекта, в котором наложены патчи обоих ветвей (`master` и `testing`).

__Merge Conflicts__

![](resources/merge-conflict.png)

- Возникают когда несколько участников отредактировали одинаковые строки,\ или когда это произошло в разных ветках.
- Разрешаются человеком при помощи инструментов (`git mergetool`).
- В реальности довольно редкая ситуация, если соблюдать практики:
 - Грамотное распределение задач
 - Частые коммиты, много маленьких веток, частая интеграция

__Multiple Branches__

![](resources/git-multiple-branches.png)

- Даже у одного разработчика может быть несколько активных веток.
- Правильно создавать отдельную ветку на каждую логически независимую задачу.
- Долгоживущие ветки — это неправильно, они быстро устаревают.

#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

Компоновка (связывание)
- Вход: объектные файлы, статические и динамические библиотеки;
- Выход:
 - статическая библиотека или динамическая библиотека или исполняемая программа
 - отладочная информация.

Статическая компоновка (связывание)
- Компоновка исполняемого модуля на этапе компиляции;
- Все функции находятся внутри выполняемого модуля;
- Все адреса переменных и функций определяются на этапе компиляции;
- "Нет зависимости" от других библиотек.

Динамическая компоновка (связывание)
- Компоновка исполняемого модуля во время исполнения;
- Библиотечные функции находятся в других модулях;
- Связывание происходит во время выполнения путём заполнения таблиц адресов;
- Явная зависимость от других библиотек.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).

> __Системы контроля версий__ — это программные системы, хранящие несколько
версий одного документа, и позволяющие вернуться к более ранним версиям. Как
правило, для каждого изменения запоминается дата модификации и автор.

История развития:
- Локальные
  - Примеры: RCS, SCCS
  - Организация одновременной работы: locks
- Централизованные
  - Примеры: Subversion, CVS
  - Организация одновременной работы: merge before commit
- Распределенные
  - Примеры: Git, Mercurial
  - Организация одновременной работы: commit before merge

Назначение:
- Системы контроля версий — центральный инструмент разработки
 - Навигация по истории изменений
 - Централизованный доступ
- Имеются и другие применения:
 - Конфигурации, документация, компьютерная анимация, САПР и др.
 - Появляется все больше примеров использования в других отраслях
   ([книгоиздание](https://github.com/certik/theoretical-physics), [государственные документы](http://www.youtube.com/watch?v=CEN4XNth61o)).

Распределенные СКВ фактически стали стандартом. Их сильные стороны:
- Допускают локальные коммиты (без наличия интернет или доступа к серверу)
- Упрощают слияние (а значит параллельную разработку)
- Дают максимальную свободу по организации рабочего процесса (workflow)

#### 12.2. CMake. Назначение, возможности, плюсы и минусы.
Это кроссплатформенная система автоматизации сборки программного обеспечения из исходного кода. CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления сборкой из файлов CMakeLists.txt

Плюсы:
- Удобен после непродолжительного обучения
- Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или простой текстовый редактор)
- Обеспечивает переносимость и является стандартом де-факто для кроссплатформенных С++ проектов

Минусы:
- "Собственный" язык
- Поначалу кажется нетривиальным

__Возможности__:
Указание необходимой версии cmake. Писать эту команду всегда - хороший стиль

    cmake_minimum_required(VERSION 2.6)

Название проекта. Указывает, что этот cmake-файл является корневым для некоторого проекта.

    project(visualization)

Переменные

    set(VARIABLE The variable's value)

Команды компилятору

    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall")

Подключение библиотек

    set(Boost_USE_STATIC_LIBS OFF)
    set(Boost_USE_MULTITHREADED ON)

Подключение заголовков

    include_directories("headers/" "more_headers/")

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).

- Без "зеленых" тестов нет уверенности в работоспособности кода
 - Фокус на максимальную автоматизацию
 - Полное тестирование требуется несколько раз в день, каждому члену команды
- __Тесты пишутся самими разработчиками, одновременно с реализацией__
 - Тесты это лучшая документация, которая всегда актуальна (компилятор!)
 - Тесты это первые сэмплы, показывающие простые примеры использования
 - Test-Driven Development
- Код тестируется __непрерывно__
 - Это делается локально на машине разработчика
 - Это делается на сервере до того, как добавить его в репозиторий
- Автоматические тесты замещают отладку
 - Предсказуемость времени разработки
 - __Пойманный баг документируется в виде теста__


Возможности фреймворков модульного тестирования:
1. Удобное добавление тестов
 - Простая регистрация новых тестов
 - Набор функций-проверок (`assert`)
 - Общие инициализации и деинициализации
1. Удобный запуск тестов
 - Пакетный режим
 - Возможность фильтрации тестов по именам
1. Часто допускают интеграцию с IDE
1. Генерация отчета в стандартном XML-формате
 - Возможность последующего автоматического анализа
 - Публикация на web-страницах проекта

#### 13.2. Метапрограммирование. Определение и примеры.

> Метапрограммирование — вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы.

Примеры:
- Шаблоны в С++
- Cog (генератор кода общего назначения)
- lex & yacc
 - Lex - лексический анализатор, позволяет осуществлять разбор входной последовательности символов с целью получения на выходе последовательности символов, называемых токенами.
 - Yacc - синтаксический анализатор, который позволяет сопоставить линейной последовательности токенов языка его формальную грамматику.


#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.
