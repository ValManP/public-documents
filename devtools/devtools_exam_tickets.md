#### 1.1. Сравнительный анализ текстового и бинарного форматов.
Преимущества простого текста
* Воспринимаемость человеком — просто понять структуру и содержание,\ часто без документации и специальных инструментальных средств.
* Простота — формат крайне удобен и его можно редактировать огромным количеством инструментов. И в первую очередь простым текстовым редактором.
* Версионируемость — файлы легко сравнивать, находить изменения.
* Переносимость — текстовый файл может быть прочитан на любой системе или ОС.
* Устойчивость — каждое слово и символ в таком файле самодостаточны и, если случится повреждение байтов в таком файле, то обычно можно восстановить данные или продолжить обработку остального содержимого.

Преимущества бинарного формата
* Минимальный размер — не содержат "разметки", часто являются сжатыми.
* Машинное представление данных, иногда допускает прямую (а значит быструю) загрузку в оперативную память (например сериализованные структуры данных). Нет необходимости в конверсии.
* Эффективность некоторых операций: поиск элементов, иногда вставка и удаление.

#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.
Ручное тестирование
* Ключевые термины
 * Тест — проверка, осуществляемая "руками"
 * Тест-план — документ со списком проверок
 * Отдел тестирования (QA)
*	Профессия ручного тестировщика вырождается!
 * За качество ответственность несут разработчики (пишут тесты!)
 * Google: Software Engineer in Test
*	Ручное тестирование используется для:
 * Тестирования GUI и UX (удобства использования)
 * Бета-тестирование с реальными пользователями

Автоматические тесты
* Тест — это "обычная" функция, реализующая некоторый сценарий использования программных сущностей.
* Тестовая сборка (test suite) — приложение с тестами, обычно консольное.

Необходимость автоматических тестов
**Тест пишется один раз, а запускается десятки тысяч раз!**
*	Развитие системы
*	Коллективное владение
*	Работа с legacy-кодом (сторонние контрибуции)
*	Портирование ПО на новые платформы
*	Тестирование новых платформ

Современная стратегия тестирования
*	Без "зеленых" тестов нет уверенности в работоспособности кода
*	Фокус на максимальную автоматизацию
 *	Полное тестирование требуется несколько раз в день, каждому члену команды
*	Тесты пишутся самими разработчиками, одновременно с реализацией
 *	Тесты это лучшая документация, которая всегда актуальна (компилятор!)
 *	Тесты это первые сэмплы, показывающие простые примеры использования
 *	Test-Driven Development
*	Код тестируется непрерывно
 *	Это делается локально на машине разработчика
 *	Это делается на сервере до того, как добавить его в репозиторий

Современная стратегия тестирования (2)
*	Автоматические тесты замещают отладку
 *	Предсказуемость времени разработки
 *	Пойманный баг документируется в виде теста
*	Тесты — это "first-class citizens"
 *	Стоит отдавать код вместе с тестами
 *	Нужно заботиться о качестве кода тестов
 *	Метафора тестов: скелет, позволяющий организму двигаться

Классификация тестов: по масштабу
*	Модульные (Unit)
*	Интеграционные
 *	Инфраструктурные
*	Системные
*	Приемочные (acceptance), функциональные

Классификация тестов: по назначению
*	Функциональные требования
 *	На задымление (smoke)
 *	Регрессионные (regression)
 *	На точность (accuracy)
 *	Соответствие/совместимость (conformance/compliance)
 *	Приемочные (acceptance)
 *	Функциональные (functional)
*	Нефункциональные требования
 *	На производительность (performance)
 *	Стресс (stress)
 *	Нагрузочные (load)
 *	Качество кода (code quality)

Критерии хорошего теста
1.	Короткий (имеет чистый код)
2.	Сфокусированный (только один assert)
3.	Быстрый
4.	Автоматический
5.	Независим от порядка исполнения и окружения
Паттерн AAA: Arrange, Act, Assert

Инструментарий
*	JUnit — тестирование приложений для Java
*	TestNG — тестирование приложений для Java
*	NUnit — порт JUnit под .NET
*	Selenium — тестирование приложений HTML;
*	TOSCA Testsuite — тестирование приложений HTML, .NET, Java, SAP
*	UniTESK — тестирование приложений на Java, Си.
	
#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.

* TXT: 
1. Документация (README, Changelog, TODO)
2. Логи (Отладочная информация, coredump)
3. Консольный вывод утилит (Разнообразные анализаторы)
  Плюсы:
 * Понятны человеку в своем исходном виде
 * Версионируемость
 * Кроссплатформенность
 * Имеют упрощенный синтаксис
 * Понятны человеку в своем исходном виде

  Минусы:
 * хз

* XML: 
1. Отчеты различных утилит (Результаты тестирования)
2. Сериализация структур данных (Представление)
3. Конфигурационные файлы( В том числе для построения)
Плюсы:
 * хз

  Минусы:
 * хз

* YAML: 
1. Конфигурационные файлы
2. Сериализованные данные
   Плюсы:
 * хз
   Минусы:
 * хз

* JSON:   
1. Сериализация структур, чаще всего в веб-приложениях(Является подмножеством YAML)
   Плюсы:
 * хз

   Минусы:
 * хз 

**Текст как исходник**
1. Все языки программирования используют текстовый формат как исходный. В том числе и ассемблер.
2. А некоторые языки, и как конечный формат распространения:
 * Скриптовые языки: bash, CMD
 * Динамические языки: Python, Perl, Ruby
 * Другие: JavaScript, MATLAB, GLSL, OpenCL (< v1.2?), CMake

Открытость исходника позволяет:
 * Читать и изучать
 * Модифицировать и переиспользовать
 * Генерировать

#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

Google Test
1. Популярный фреймворк для написания модульных тестов на С++,\ разработанный Google.
2. Open-source проект c BSD-лицензией\ (допускает использование в закрытых коммерческих проектах).
3. Используется в целом ряде крупных проектов
 * Chromium, LLVM компилятор, OpenCV
4. Написан на C++, строится при помощи CMake
 * Поддерживает: Linux, Mac OS X, Windows, Cygwin, Windows CE и Symbian
5. Как правило используется в консольном режиме, но существует вспомогательное GUI приложение.

Возможности Google Test
* Automatic test discovery
* Rich set of assertions, user-defined assertions
* Death tests
* Fatal and non-fatal failures
* Value- and type-parameterized tests
* Various options for running the tests
* XML test report generation

Базовые концепции

![](resources/gtest_concepts.png)

* Каждый тест реализован как функция, с использованием макроса TEST() или TEST_F().
* TEST() не только определяет, но и "регистрирует" тест.

Полезные советы
* Тесты можно временно выключать
* Тесты можно фильтровать по имени при запуске
* У Google Test есть ряд других полезных опций

Приложение: Порядок использования Google Test

* Начальная стадия

1. Скомпилировать Google Test в библиотеку.
2. Создать новое консольное приложение (test suite)\ и прилинковать к нему библиотеку Google Test.
3. Добавить тесты.
4. Скомпилировать приложение с тестами и запустить его.

* Основная стадия

1. Новые тесты добавляются в тот же test suite, их могут быть тысячи.
2. При необходимости test suite разбивается на несколько
3. Корректность и производительность
4. Быстрый (pre-commit) и полный (ночной)

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.

Инструменты командной строки
1. Просмотр
 * cat/tac, head/tail, less
2. Поиск
 * grep
3. Обработка
 * sed, awk

Преимущества:
1. Удобство
2. Возможность работы со скрытыми функциями

Недостатки:
1. Необходимо знание команд

**Grep examples**

Многоцелевая поисковая утилита, использующая регулярные выражения. Изначально это была команда в древнем строчном редакторе ed, g/re/p, что означает -- global - regular expression - print.

       grep pattern [file...]

Поиск участков текста в файле(ах), соответствующих шаблону pattern, где pattern может быть как обычной строкой, так и регулярным выражением.
 * grep -nIHR "^#" --include=*.md ./
  * Вывод всех заголовков в Markdown файлах ("| wc -l" добавит их подсчет)
 * grep -nIHR "class.*Matcher" --include=*.hpp -B1 ./
  * Печать деклараций всех классов, содержащих слово Matcher (+одна строка до)

**Sed examples**
Неинтерактивный "потоковый редактор". Широко используется в сценариях на языке командной оболочки.
Stream editor

* sed 's/foo/bar/g' — заменяет foo на bar
* sed '/baz/s/foo/bar/g' — то же самое, но если строка содержит baz
* sed 's/[ \t]*$//' — удалить "висячие" пробельные символы
* sed '/regex/G' — вставить пустую строку под каждой, содержащей "regex"
* sed 'n;n;n;n;G;' — вставить пустую строку через каждые 5
* sed -n '$=' — посчитать количество строк
* sed '1,10d' — удалить первые 10 строк файла

**Awk examples**
Утилита контекстного поиска и преобразования текста, замечательный инструмент для извлечения и/или обработки полей (колонок) в структурированных текстовых файлах. Синтаксис awk напоминает язык C.
                 
    awk — pattern-directed scanning and processing language
Authors: Aho, Weinberger, Kernighan

Примеры:

* awk '{print NR "\t" $0}' — распечатать файл с номерами строк
* awk 'END{print NR}' — вывести число строк в файле
* awk '{print $2, $1}' — распечатать второе и первое поле в обратном порядке
* awk '{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}' — вывести сумму полей для * каждой строки
* awk '{sub(/[ \t]+$/, "")};1' — удалить "висячие" пробельные символы
* awk '{l=length();s=int((79-l)/2); printf "%"(s+l)"s\n",$0}' filename — центрировать и распечатать файл

#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

Непрерывная интеграция (англ. Continuous Integration) — это практика разработки ПО, которая заключается в выполнении частых автоматизированных сборок проекта для скорейшего выявления и решения интеграционных проблем.
Непрерывная сборка — это сердцебиение вашего проекта.

**Эволюция взглядов на интеграцию**

Можно условно представить в виде следующих практик:
1. Waterfall: разделить на компоненты, реализовать, интеграция — отдельная фаза
2. Nightly build: интегрироваться часто, ночной билд (heartbeet of the project)
3. Continuous Integration: интегрироваться непрерывно, тестирование каждого вливания
4. Pre-commit Testing: интегрироваться непрерывно, но после проверки стабильности
5. Continuous Deployment: развертываться непрерывно, сразу после проверки стабильности

На GitHub механизмом pull request реализуется Pre-Commit Testing

**Реализация**
Задачи выделенного сервера
1. Получение исходного кода из репозитория
2. Сборка проекта (в том числе построение дистрибутивов)
3. Выполнение тестов и автоматических проверок
4. Отправка отчетов (хранение истории и статистики)
5. Развёртывание готового проекта

**Преимущества**
* Проблемы интеграции выявляются и исправляются быстро, что оказывается дешевле;
* Немедленный прогон модульных тестов для свежих изменений;
* Постоянное наличие текущей стабильной версии вместе с продуктами сборок — для тестирования, демонстрации, и т. п.
* Немедленный эффект от неполного или неработающего кода приучает разработчиков к работе в итеративном режиме с более коротким циклом.

Автоматические проверки: Статический анализ
1. Проверки на корректность
 * Максимальный уровень предупреждений компилятора (нескольких компиляторов!)
 * Автоматический поиск ошибок (PVS-Studio, cppcheck, Coverity Scan)
 * Соответстиве стандартам (стандарт ASIL - инструмент LDRA)
2. Стиль кодирования (lint, vera++, cpplint.py)
 * Чистый код (именование, форматирование)
 * Анализ сложности кода
3. Специальные инструменты
 * ABI compliance checker
 * Поиск IP проблем, например GPL кода ()

Автоматические проверки: Динамический анализ
1. Анализ покрытия кода тестами (gcov, BullseyeCoverage)
2. Утечки памяти, гонки данных (Valgrind, BoundsChecker)
3. Анализ производительности (GoogleTest)
4. Intel Parallel Studio

**Недостатки**
* Затраты на поддержку работы непрерывной интеграции;
* Потенциальная необходимость в выделенном сервере под нужды непрерывной интеграции;
* Немедленный эффект от неполного или неработающего кода отучает разработчиков от выполнения периодических резервных включений кода в репозиторий.
* В случае использования системы управления версиями исходного кода с поддержкой ветвления, эта проблема может решаться созданием отдельной «ветки» (англ. branch) проекта для внесения крупных изменений (код, разработка которого до работоспособного варианта займет несколько дней, но желательно более частое резервное копирование в репозиторий). По окончании разработки и индивидуального тестирования такой ветки, она может быть объединена (англ. merge) с основным кодом или «стволом» (англ. trunk) проекта.

Примеры систем
1. Hudson > Jenkins
2. CruiseControl (CruiseControl.NET), TeamCity
3. Travis CI, AppVeyor, [Drone.IO][https://drone.io]
4. BuildBot

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
Регулярные выражения (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (англ. wildcard characters).

По сути это строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов, и задающая правило поиска.
Wikipedia

Метасимволы: [ ] \ / ^ $ . | ? * + ( ) { }

**Примеры регулярных выражений**
* polynomial
* 3\.1415926
* static
* static .*(.*;
* ^class
* [0-9]{6}

**Синтаксис**
* Обычные строки обозначают сами себя
* . — может быть использована вместо любого символа
* \ — экранирует метасимволы (/ иногда используется как разделитель)
* ( ) — группировка, указывает приоритет операций
* [ ] — обозначает символьный класс ([abc], [0123456789], [а-я], [0-9])
* ^ $ — указывают на начало и конец строки
* ? * + { } — указывают число повторений

**Назначение:**
Обычно с помощью регулярных выражений выполняются три действия:
* Проверка наличия соответствующей шаблону подстроки.
* Поиск и выдача пользователю соответствующих шаблону подстрок.
* Замена соответствующих шаблону подстрок.

#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

Задачи выделенного сервера
1. Получение исходного кода из репозитория
2. Сборка проекта (в том числе построение дистрибутивов)
3. Выполнение тестов и автоматических проверок
4. Отправка отчетов (хранение истории и статистики)
5. Развёртывание готового проекта

![](resources/bbot-overview.png)

BuildBot
Преимущества:
1. Реализован на Python, как результат переносим и допускает кастомизацию (программирование билдеров)
2. Поддержка большого числа языков.
Недостатки:
1. Сложная настройка.


1. Система Buildbot использует архитектуру ведущих/ведомых серверов, которая предусматривает единственный центральный сервер и множество управляемых им серверов для сборки.
2.	Удаленное исполнение команд осуществляется в полном соответствии со сценарием центрального сервера в реальном времени. 
3.	Планирование выполнения команд и запросы сборки не только координируются, но и полностью контролируются центральным сервером.
4.	Система Buildbot поддерживает постоянное соединение с каждой системой для сборки и осуществляет управление и координацию исполнения задач этими системами. Это постоянное соединение упрощает процессы координации и управления ресурсами.
5.	В системе Buildbot предусмотрены блокировки для центрального и ведомых серверов на центральном сервере, поэтому могут координироваться как глобальные сборки в рамках всей системы, так и локальные сборки в рамках ресурсов отдельных машин. Это обстоятельство делает систему Buildbot в большей степени пригодной для больших систем, на которых проводится тесты системной интеграции.
6.	Каждый новый сервер для сборки должен быть явно задан при настройке центрального сервера, что делает невозможным динамическое подключение к центральному серверу новых серверов для сборки и их последующую эксплуатацию.
7.	Каждый сервер для сборки находится под полным управлением центрального сервера, серверы сборки уязвимы для умышленных и случайных операций задания некорректных настроек: центральный сервер буквально осуществляет тотальный контроль клиента, контролируя также ограничения безопасности операционной системы клиента.
8.	Другим последствием использования модели ведущих/ведомых серверов и ее ограниченного канала для взаимодействия является невозможность отправки отчетов о загрузке системы центральному серверу от ведомых серверов, поэтому центральный сервер не может избегать больших нагрузок на системы сборки.

Travis СI

Преимущества:
1. Интеграция с GitHub
2. Возможность бесплатного использования
3. Поддерживает большое количество языков
4. Тестирование происходит на виртуальных Linux-машинах, запускаемых в облаке Amazon
Недостатки:
1. Отсутствие проверки на Windows серверах

Настройка Travis:
1. Заходим на сайт сервиса, логинимся с помощью github аккаунта. Заходим в настройки профиля, и включаем репозиторий, на котором мы хотим гонять билды и тесты.
2. Большая часть настройки осуществляется в файле .travis.yml, который необходимо положить в корневую папку вашего репозитория. В процессе может пригодиться travis-lint, руби гем, позволяющий валидировать этот файл на корректность.
3. Настройка всех необходимых зависимостей для проекта. Имеются следующие шаги работы воркера Travis:
4. Работа со скриптом, прогоняющем тесты.
5. Делаем коммит в одну из веток, и запушить изменения на github. Travis-CI автоматически запланирует билд, и через минуту-две начнет собирать проект. Если все пройдет успешно — статус станет зеленым, если нет — красным. Одновременно на почту отправится сообщение об успешности или неудаче сборки. 

#### 5.1. СКВ. Основные функции и термины, базовые принципы.

**Системы контроля версий**
Системы контроля версий — это программные системы, хранящие несколько версий одного документа, и позволяющие вернуться к более ранним версиям. Как правило, для каждого изменения запоминается дата модификации и автор.

Патчи
Патч (англ. patch — заплатка) — информация, предназначенная для автоматизированного внесения определённых изменений в компьютерные файлы.

* Патч — это простой текстовый файл, его можно наложить при помощи инструментов (patch).
* Один патч может содержать изменения сразу нескольких файлов в разных директориях.
* Люди могут обмениваться изменениями, посылая друг другу патчи.
* Патч — это атомарное изменение проекта!

Патчи и СКВ
* СКВ — это своего рода БД патчей, ее называют репозиторием.
* Патчи, помещенные в СКВ называются commit.
* Последовательности commit называются changeset.

**Поколения СКВ**
1. Локальные

![](resources/local-vcs.png)

* Примеры: RCS, SCCS
* Организация одновременной работы: locks

2. Централизованные

![](resources/centralized-vcs.png)

* Примеры: Subversion, CVS
* Организация одновременной работы: merge before commit

3. Распределенные

![](resources/distributed-vcs.png)

* Примеры: Git, Mercurial
* Организация одновременной работы: commit before merge

Преимущества распределенных СКВ (DVCS)
1. Допускают локальную работу (коммиты без наличия интернет)
2. Упрощают слияние (а значит параллельную разработку)
3. Дают максимальную свободу по организации рабочего процесса (workflow)
   Благодаря этому, они фактически стали стандартом де-факто.

**Понятие ветки (branch)**
* Ветка в Git'е — это просто указатель на один из коммитов.
* Есть соглашение, что имя master используется для ветки,\ указывающей на последнее актуальное состояние проекта.

**HEAD**
* HEAD — специальный указатель, ссылающийся на локальную ветку, на которой вы находитесь.
* Это просто алиас (псевдоним) для текущей ветки, введенный для удобства.

**Резюме:**
1. Системы контроля версий — центральный инструмент разработки
 * Навигация по истории изменений
 * Централизованный доступ
2. Имеются и другие применения:
 * Конфигурации, документация, компьютерная анимация, САПР и др.
 * Появляется все больше примеров использования в других отраслях (книгоиздание, государственные документы).
3. Распределенные СКВ фактически стали стандартом. Их сильные стороны:
 * Допускают локальные коммиты (без наличия интернет или доступа к серверу)
 * Упрощают слияние (а значит параллельную разработку)
 * Дают максимальную свободу по организации рабочего процесса (workflow)
4. Git не самая простая в освоении СКВ, однако очень функциональная,\ к тому же дает максимальную свободу по организации процесса разработки.


#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

Git Flow:
![](resources/git-flow.png)

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.
#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.
#### 8.2. ИСР. Назначение, состав, возможности.

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.
#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#### 10.2. UNIX. Философия и преимущества при автоматизации.

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).
#### 12.2. CMake. Назначение, возможности, плюсы и минусы.

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).
#### 13.2. Метапрограммирование. Определение и примеры.

#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.






