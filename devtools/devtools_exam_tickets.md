#### 1.1. Сравнительный анализ текстового и бинарного форматов.
#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.

#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.
#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.
#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

#### 5.1. СКВ. Основные функции и термины, базовые принципы.
#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

>**API (Application Programming Interface)** - набор готовых классов, процедур, функций, структур и констант, предоставляемых ОС, приложением, библиотекой для использования во внешних программных продуктах.

- Все современные ОС предоставляют API;
- Все прикладные приложения явно или косвенно от него зависят;
- Необходимо поддерживать совместимость.

**Совместимости:**

- **Бинарная** - совместимость на уровне бинарных интерфейсов (ABI). Модуль можно заменить другим без потерь.
- **На уровне исходных кодов** (API, source). Замена библиотеки на другую не ломает компиляцию и логику программы.

**Способы реализации API:**
- Программные прерывания процессора;
- Динамическая компоновка и вызов библиотечных функции;
- Формирование пакетов данных соответствующих общим соглашениям.

**Бинарная совместимость в С++:**

1. Совпадают сигнатуры всех функций и методов;
2. Совпадает sizeof для всех экспортируемых объектов;
3. Совпадает состав всех структур, в том числе выравнивание;
4. Совпадают значения параметров по умолчанию;
5. Совпадают виртуальные методы, не добавляется новых виртуальных методов;
6. Совпадает иерархия виртуального наследования;
7. Могут отличаться имена констант, если они не экспортируются из библиотеки как символ;
8. Могут отличаться имена и структура макросов;
9. Могут быть добавлены новые невиртуальные методы;
10. Могут быть добавлены перегрузки функций, если функция уже была перегружена.

**Совместимость на уровне исходного кода в C++:**

1. Может отличаться число параметров функции, если определены значения по умолчанию для новых параметров;
2. Могут быть добавлены перегрузки методов;
3. Могут отличаться виртуальные методы;
4. Могут отличаться sizeof, выравнивание и поля структур;
5. Совпадают имена всех констант и макросов.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

**Назначение:**

Git - распределенная СКВ (DVCS). Каждый имеет у себя локальную копию репозитария с сервера.

- Разработан Линусом Торвальдсом для работы над ядром Linux в 2005 году.
- В настоящее время поддерживается Джунио Хамано, сотрудником Google.
- Не очень прост в освоении, однако очень быстрый и функциональный.
- Имеет наиболее "сильное" сообщество, инструментальную поддержку.

**Преимущества:**

- Распределенная СКВ - можно коммитить столь часто, сколь угодно, даже если в данный момент отсутствует соединение с сервером.
- Работа с несколькими ветками.
- Удобный механизм слияния (merge).

**Интерфейс:**

![](resources/git-cheat-sheet.png)

**GutHub Flow:**

Anything in the `master` branch is deployable.

1. Create branch
  - To work on something new, create a descriptively named branch off of `master` (ie: `new-oauth2-scopes`).
2. Develop in branch
  - Commit to that branch locally and regularly push your work to the same named branch on the server.
3. Open a pull request (ask for review)
  - When you need feedback or help, or you think the branch is ready for merging, open a pull request.
4. Merge after review
  - After someone else has reviewed and signed off on the feature, you can merge it into `master`.
5. Deploy
  - Once it is merged and pushed to `master`, you can and *should* deploy immediately.

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

>**Исполняемый модуль** — файл, содержащий программу в виде, в котором она может быть (после загрузки в память и настройки по месту) исполнена вычислительной машиной.

**ELF модуль на UNIX (1)**

![](./resources/Elf-layout.png)

**ELF модуль на UNIX (2)**

1. Заголовок файла:
  - Архитектура аппаратной платформы;
  - Аппаратно зависимые флаги;
  - Точка входа
2. Таблица заголовков сегментов;
3. Таблица заголовков секций;
4. Данные сегментов и секций.

**ELF модуль на UNIX (3)**

**Сегмент** - это непрерывная область адресного пространства со своими
атрибутами доступа. В частности, сегмент кода имеет атрибут исполнения, а
сегмент данных — атрибуты чтения и записи.

**Секция** - фрагмент сегмента, имеющий определённое назначение:

- .init (процедуры инициализации);
- .plt (секция связок);
- .text (основой код программы);
- .fini (процедуры финализации).

Информация о сегментах используется при выполнении (Run-time).
Информация о секциях используются при динамической компоновке (Link-time).
Исполняемые файлы, `*.so`, `*.a`, `*.o` файлы используют ELF формат.

**PE Модуль на Windows (1)**

![](./resources/Pe-layout.png)

**PE Модуль на Windows (2)**

PE = Portable Executable

1. MS DOS часть для совместимости;
2. PE заголовок
  - Архитектура аппаратной платформы;
  - Аппаратно зависимые флаги;
  - Подсистема Windows (GUI, CUI, OS/2, Posix);
  - Точка входа;
  - Контрольная сумма;
3. Заголовки секций;
4. Данные секций.

**PE Модуль на Windows (3)**

- Исполняемые файлы `*.exe`, динамические библиотеки `*.dll` и драйверы используют
   PE формат;
- Формат несколько раз расширялся и некоторые функции могут быть реализованы
   по-разному;
- Не все инструменты одинаково интерпретируют/генерируют PE файлы;
- В PE  модуле есть отдельная секция ресурсов.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.

**Преимущества:**

- Мощность / повышение уровня абстракции
  - Фокус на основной задаче
  - Меньшее количество переключений контекста
- Надежность
  - Отсутствие человеческого фактора
- Скорость
- Дешевизна
  - Особенно при многократном запуске
- Освобождение времени

**Типичные классы задач на автоматизацию (в работе программиста):**
- Слепая печать
- Сбор и обработка данных
  - Составление отчетов/графиков, анализ и обработка больших массивов данных
- Тестирование
  - Изменения ничего не сломали, анализ производительности
- Администрирование
  - Регулярные процедуры (бэкап), сложное конфигурирование
- Собственно, автоматизация
  - Построение дистрибутивов, развертывание

#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

- **Отладка** - это процесс нахождения и устранения ошибок и дефектов в компьютерной программе или в электронном оборудовании.
- **Отладчик** - это компьютерная программа, которая используется для тестирования и отладки других программ.

**Общие определения:**

- **Breakpoint** (точка останова) - это преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика.
- **Watchpoint** - точка останова по данным. Срабатывает, когда меняется значение заданного выражения или переменной.
- **Catchpoint** - специальная точка останова, которая срабатывает при достижении специального события, например, C++ исключения или загрузки библиотеки.
- **Call stack** (стек вызовов) - хранит информацию об активных процедурах и функциях.

**Распространенные техники отладки**:

- Printf отладка, трассирование и логирование
- Post-mortem отладка (дамп памяти, логи)
- Использование специальных программ (отладчиков)
- Проверка различных утверждений в коде (assert)
- Алгоритм "волчья ограда"

**Edward Gauss - "Wolf fence" algorithm:**

"There's one wolf in Alaska, how do you find it? First build a fence down the middle of the state, wait for the wolf to howl, determine which side of the fence it is on. Repeat process on that side only, until you get to the point where you can see the wolf)."
In other words: put in a few "print" statements until you find the statement that is failing (then maybe work backwords from the "tracks" to find out where the wolf/bug comes from).

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.

**Назначение:**

- Это язык разметки текстовой информации
- Имеет упрощенный синтаксис
- Ориентирован для редактирования из простого текстового редактора
- Понятен человеку в своем исходном виде

**Синтаксис:**

![](resources/markdown-cheat-sheet.jpg)

**Примеры использования:**

- GitHub: wiki and comments using GFM.
- StackOverflow: questions and answers editing.
- Askbot: the same as StackOverflow.
- Создание книг.
- Создание презентаций.
- Создание статических сайтов.

**Особенности использования:**

- Вероятно, самый популярный из легковесных языков разметки на сегодняшний день.
- Используется на StackOverflow и GitHub в качестве языка для wiki и комментариев.
- Поддерживается редакторами, оброс большим количеством инструментов.
- Минус: встречаются расхождения в "толковании". Но уже есть CommonMark!

#### 8.2. ИСР. Назначение, состав, возможности.

>**Интегрированная среда разработки**, ИСР (англ. IDE, Integrated development environment или integrated debugging environment) — система программных средств, используемая программистами для разработки программного обеспечения.

**Отличия ИСР от редакторов исходного кода:**

- Наличие компилятора 
- Анализ кода 
- Средства автоматизации сборки 
- Наличие отладчика 
- Наличие средств интеграции с СКВ 
- Браузер классов 
- Диаграмма иерархии классов 
- Инспектор объектов

**Основные функции/возможности современных ИСР:**

- Автодополнение кода
- Поддержка шаблонов проектов
- Сниппеты
- Поддержка систем контроля версий
- Интеграция задач (//TODO: ...)
- Браузер классов
- Визульное редактирование классов
- Инструменты рефакторинга
- Профилировщик
- Работа с СУБД, веб-сервисами

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.

**Важные свойства редакторов:**

- Кросс-платформенность
- Настраиваемость
  - Шрифты, оформление, клавиатурные комбинации
- Расширяемость
  - Новые языки программирования и форматы файлов
- Программируемость
  - Программируемость сложных операций (макросы, сценарии)
- Скорость работы

**Возможности:**

- Навигация
  - По файлам
    - Перебор закладок
    - Боковая панель
    - Go to anything
  - Внутри файлов
    - Хождение по словам, строкам, экрану
    - Переход на строку
    - Переход между скобками
   - Go to symbol
- Выделение
  - Слов, Строк
  - Абзацев
  - Выражений внутри скобок
  - Всех вхождений слова => Поиск
- Поиск
  - Простой поиск
    - Multiple cursor
    - Регулярные выражения
  - Инкрементальный
  - Быстрый
- Редактирование
  - Комментирование
  - Перестановка двух символов
  - Удаление: слов, строк, окончаний строк
  - Манипуляции со строками
    - Дублирование, переупорядочение, сортировка
    - Слияние и автоматический перенос
  - Редактирование нескольких строк и прямоугольных регионов
- Продвинутые возможности
  - Package Control
  - Snippets
  - Vintage Mode
  - Custom Builds
  - Projects

**Vim** - свободный текстовый редактор, созданный на базе vi. Один из культовых редакторов. Один из мощнейших редакторов с полной свободой настройки и автоматизации. Имеет огромное количество расширений (более 3000). Используется практически в любых проектах.

**Примеры команд:**

- `5D`, `Y5p` - удалить/повторить строку 5 раз
- `/^joe` - найти все строки, начинающиеся с joe
- `:g!/REGEXP/d` - удалить все строки, не содержащие REGEXP
- `:%norm jdd` - удалить каждую вторую строку
- `ci(`, `ci[` - удалить содержимое внутри скобок
- `guu`, `gUU` - перевести всю строку в нижний/верхний регистр

**Emacs** - семейство расширяемых многофункциональных текстовых редакторов. Второй культовый редактор. Возможно, еще более мощный редактор, чем Vim (Emacs as OS). Имеет более 2000 встроенных команд, позволяет комбинировать их в макросы.

**Идеология Emacs:**
- "Всё в одном"
  - Функциональность: базовая, основной режим, дополнительные режимы
- Расширяемость
  - Программируется на Elisp, имеются пакеты расширений, клавиатурные комбинации
- Настраиваемость под пользователя
  - Elisp-переменные, определение функций, создание hook'ов
- Документированность
  - Подробная документация, вплоть до функций и переменных

**Sublime Text** - кроссплатформенный редактор текста и кода. Имеет Python API, существует большое количество раширений. Не является свободным, однако почти все расширения открыты. Становится все более популярным.

Самый информативный - Vim (куча окошечек: несколько окон с исходным кодом, структура проекта, СКВ история, браузер классов, все открыто сразу).
Самый каноничный и олдскульный - Emacs.
Sublime Text - как Vim, только с интерфейсом, похожим на студию.

#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

- **Отладка** - это процесс нахождения и устранения ошибок и дефектов в компьютерной программе или в электронном оборудовании.
- **Отладчик** - это компьютерная программа, которая используется для тестирования и отладки других программ.

**Общие определения:**

- **Breakpoint** (точка останова) - это преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика.
  **Примеры команд для GDB:** break, rbreak, tbreak
- **Watchpoint** - точка останова по данным. Срабатывает, когда меняется значение заданного выражения или переменной.
  **Примеры команд для GDB:** watch, rwatch, awatch
- **Catchpoint** - специальная точка останова, которая срабатывает при достижении специального события, например, C++ исключения или загрузки библиотеки.
- **Call stack** (стек вызовов) - хранит информацию об активных процедурах и функциях.
  **Примеры команд для GDB:** catch throw, catch catch, catch syscall, catch load.

**Распространенные техники отладки**:

- Printf отладка, трассирование и логирование
- Post-mortem отладка (дамп памяти, логи)
- Использование специальных программ (отладчиков)
- Проверка различных утверждений в коде (assert)
- Алгоритм "волчья ограда"

**Отладочная информация:**

Любой компилятор по умолчанию снабжает объектный файл отладочной информацией. Вся эта отладочная информация предназначается для отладки программы отладчиком. Отладочная информация может значительно увеличить объем файла (в 3-4 раза). Для создания программ "релизов" существует отдельная программа, позволяющая удалить отладочную информацию из запускаемого файла (например, strip).

**Полезные опции для GCC компилятора:**

- **`-g<level>`** - отладочная информация в нативном формате для операционной системы
  - level = 0 - нет отладочной информации
  - level = 1 - минимально необходимая информация
  - level = 3 - дополнительная информация
- **`-ggdb<level>`** - информация в формате GDB
- **`-O0`** - отключение всех оптимизаций компилятора
- **`-fno-omit-frame-pointer`** - использовать указатель на фрейм

**Запуск программ из под GDB:**

- **`$ gdb --args <программа с аргументами>`**
- **`$ gdb <программа> [<pid>] [<core-файл>]`**
- **`r, run [аргументы]`** - запуск программы под GDB
- **`start [аргументы]`** - удобный способ запуска программы с точкой останова на первой строчке функции `main`
- **`attach <pid> / detach`** - отладка уже запущенного процесса

**Продолжение и пошаговое исполнение:**

- **`continue, c, fg`** - возобновление исполнения программы
- **`s, step [count]`** - продолжить исполнение до следующей строчки исходного кода
- **`n, next [count]`** - продолжить исполнение до следующей строчки исходного кода в текущем фрейме
- **`ni, nexti, si, stepi [count]`** - так же как `next` и `step`, но для инструкции
- **`fin, finish`** - продолжить исполнение до тех пор, пока текущая функция не завершится
- **`u, until [location]`** - продолжить исполнение до тех пор, пока не достигнута следующая строчка

**Вывод информации о стеке вызовов:**

- **`bt, backtrace [full] [n]`** - напечатать стек вызовов
- **`frame [n]`** - навигация по текущему стеку вызовов
- **`info frame`** - вывести подробную информацию о текущем стековом фрейме
- **`info args`** - вывести аргументы для текущего фрейма
- **`info locals`** - вывести локальные переменные для текущего фрейма

**Просмотр данных:**

- **`print [/fmt] <expr>`** - показать значение выражения
  - a - указатель
  - x - шестнадцатеричное целое
  - s - трактовать как C-строку
  - u - беззнаковое целое
- **`print *address@<len>`** - показать массив
- **`display [/fmt] <expr>`** - показывать каждый раз
- **`delete/disable/enable display <id>`** - управлять списком для отображения данных
- **`info display`** - вывести список выражений для отображения
- **`info <registers | all-registers>`** - показать регистры

**Навигация по исходным файлам:**

- **`l, list [linenum | function | - | +]`** - показать код
- **`forward-search, search regexp`** - искать в прямом направлении в текущем файле
- **`reverse-search regexp`** - искать в обратном направлении в текущем файле
- **`dir, directory <dirname>`** - добавить директории для поиска файлов
- **`set substitute-path <to> <from>`** - определить подстановочное правило для директории
- **`disassemble [/m | /r] [start,+length]`** - показать диапазон памяти, как инструкции процессора

**Исполнение в обратном направлении:**

- **`record [full]`** - начать процесс записи
- **`record stop`** - остановить процесс записи
- **`reverse-continue, reverse-step, reverse-next, reverse-nexti,`**
  **`reverse-stepi, reverse-finish`** - команды для обратного исполнения программы
- **`checkpoint`** - сделать снимок состояния программы
- **`restart <checkpoint-id>`** - восстановить состояние
- **`info checkpoints`** - информация о всех checkpoints
- **`delete checkpoint <id>`** - удалить checkpoint

**Текстовый пользовательский интерфейс:**

- Запустить `gdb -tui` и **C-x C-a** сочетание клавиш
- В TUI режиме, gdb может отображать несколько окон:
  - command - GDB командная строка и вывод
  - source - показывает исходный код программы
  - assembly - показывает вывод дизассемблера
  - register - показывает регистры процессора
- `layout <prev | next | asm | src | split | regs>`
- `focus <prev | next | asm | src | split | regs | cmd>`
- `refresh` (или **C-L** сочетание клавиш)

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#### 10.2. UNIX. Философия и преимущества при автоматизации.

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).
#### 12.2. CMake. Назначение, возможности, плюсы и минусы.

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).
#### 13.2. Метапрограммирование. Определение и примеры.

#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.
