#### 1.1. Сравнительный анализ текстового и бинарного форматов.
#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.

#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.
#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.
#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

#### 5.1. СКВ. Основные функции и термины, базовые принципы.
#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

Git Flow:
![](resources/git-flow.png)

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.
#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.
#### 8.2. ИСР. Назначение, состав, возможности.

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.
#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#### 10.2. UNIX. Философия и преимущества при автоматизации.

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).
#### 12.2. CMake. Назначение, возможности, плюсы и минусы.

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).
#### 13.2. Метапрограммирование. Определение и примеры.

#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.

## Билет 1 ##
**1. Сравнительный анализ текстового и бинарного форматов**

Преимущества простого текста
* Воспринимаемость человеком — просто понять структуру и содержание,\ часто без документации и специальных инструментальных средств.
* Простота — формат крайне удобен и его можно редактировать огромным количеством инструментов. И в первую очередь простым текстовым редактором.
* Версионируемость — файлы легко сравнивать, находить изменения.
* Переносимость — текстовый файл может быть прочитан на любой системе или ОС.
* Устойчивость — каждое слово и символ в таком файле самодостаточны и, если случится повреждение байтов в таком файле, то обычно можно восстановить данные или продолжить обработку остального содержимого.

Преимущества бинарного формата
* Минимальный размер — не содержат "разметки", часто являются сжатыми.
* Машинное представление данных, иногда допускает прямую (а значит быструю) загрузку в оперативную память (например сериализованные структуры данных). Нет необходимости в конверсии.
* Эффективность некоторых операций: поиск элементов, иногда вставка и удаление.

**2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.**

Ручное тестирование
* Ключевые термины
 * Тест — проверка, осуществляемая "руками"
 * Тест-план — документ со списком проверок
 * Отдел тестирования (QA)
*	Профессия ручного тестировщика вырождается!
 * За качество ответственность несут разработчики (пишут тесты!)
 * Google: Software Engineer in Test
*	Ручное тестирование используется для:
 * Тестирования GUI и UX (удобства использования)
 * Бета-тестирование с реальными пользователями

Автоматические тесты
* Тест — это "обычная" функция, реализующая некоторый сценарий использования программных сущностей.
* Тестовая сборка (test suite) — приложение с тестами, обычно консольное.

Необходимость автоматических тестов
**Тест пишется один раз, а запускается десятки тысяч раз!**
*	Развитие системы
*	Коллективное владение
*	Работа с legacy-кодом (сторонние контрибуции)
*	Портирование ПО на новые платформы
*	Тестирование новых платформ

Современная стратегия тестирования
*	Без "зеленых" тестов нет уверенности в работоспособности кода
*	Фокус на максимальную автоматизацию
 *	Полное тестирование требуется несколько раз в день, каждому члену команды
*	Тесты пишутся самими разработчиками, одновременно с реализацией
 *	Тесты это лучшая документация, которая всегда актуальна (компилятор!)
 *	Тесты это первые сэмплы, показывающие простые примеры использования
 *	Test-Driven Development
*	Код тестируется непрерывно
 *	Это делается локально на машине разработчика
 *	Это делается на сервере до того, как добавить его в репозиторий

Современная стратегия тестирования (2)
*	Автоматические тесты замещают отладку
 *	Предсказуемость времени разработки
 *	Пойманный баг документируется в виде теста
*	Тесты — это "first-class citizens"
 *	Стоит отдавать код вместе с тестами
 *	Нужно заботиться о качестве кода тестов
 *	Метафора тестов: скелет, позволяющий организму двигаться

Классификация тестов: по масштабу
*	Модульные (Unit)
*	Интеграционные
 *	Инфраструктурные
*	Системные
*	Приемочные (acceptance), функциональные

Классификация тестов: по назначению
*	Функциональные требования
 *	На задымление (smoke)
 *	Регрессионные (regression)
 *	На точность (accuracy)
 *	Соответствие/совместимость (conformance/compliance)
 *	Приемочные (acceptance)
 *	Функциональные (functional)
*	Нефункциональные требования
 *	На производительность (performance)
 *	Стресс (stress)
 *	Нагрузочные (load)
 *	Качество кода (code quality)

Критерии хорошего теста
1.	Короткий (имеет чистый код)
2.	Сфокусированный (только один assert)
3.	Быстрый
4.	Автоматический
5.	Независим от порядка исполнения и окружения
Паттерн AAA: Arrange, Act, Assert

Инструментарий
*	JUnit — тестирование приложений для Java
*	TestNG — тестирование приложений для Java
*	NUnit — порт JUnit под .NET
*	Selenium — тестирование приложений HTML;
*	TOSCA Testsuite — тестирование приложений HTML, .NET, Java, SAP
*	UniTESK — тестирование приложений на Java, Си.

## Билет 2 ##
**1. Языки разметки(XML, YAML, JSON). Назначение. Плюсы и минусы каждого из них.**

* TXT: 
1. Документация (README, Changelog, TODO)
2. Логи (Отладочная информация, coredump)
3. Консольный вывод утилит (Разнообразные анализаторы)
  Плюсы:
 * Понятны человеку в своем исходном виде
 * Версионируемость
 * Кроссплатформенность
 * Имеют упрощенный синтаксис
 * Понятны человеку в своем исходном виде

  Минусы:
 * хз

* XML: 
1. Отчеты различных утилит (Результаты тестирования)
2. Сериализация структур данных (Представление)
3. Конфигурационные файлы( В том числе для построения)
Плюсы:
 * хз

  Минусы:
 * хз

* YAML: 
1. Конфигурационные файлы
2. Сериализованные данные
   Плюсы:
 * хз
   Минусы:
 * хз

* JSON:   
1. Сериализация структур, чаще всего в веб-приложениях(Является подмножеством YAML)
   Плюсы:
 * хз

   Минусы:
 * хз 

**Текст как исходник**
1. Все языки программирования используют текстовый формат как исходный. В том числе и ассемблер.
2. А некоторые языки, и как конечный формат распространения:
 * Скриптовые языки: bash, CMD
 * Динамические языки: Python, Perl, Ruby
 * Другие: JavaScript, MATLAB, GLSL, OpenCL (< v1.2?), CMake

Открытость исходника позволяет:
 * Читать и изучать
 * Модифицировать и переиспользовать
 * Генерировать

**2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.**

Google Test
1. Популярный фреймворк для написания модульных тестов на С++,\ разработанный Google.
2. Open-source проект c BSD-лицензией\ (допускает использование в закрытых коммерческих проектах).
3. Используется в целом ряде крупных проектов
 * Chromium, LLVM компилятор, OpenCV
4. Написан на C++, строится при помощи CMake
 * Поддерживает: Linux, Mac OS X, Windows, Cygwin, Windows CE и Symbian
5. Как правило используется в консольном режиме, но существует вспомогательное GUI приложение.

Возможности Google Test
* Automatic test discovery
* Rich set of assertions, user-defined assertions
* Death tests
* Fatal and non-fatal failures
* Value- and type-parameterized tests
* Various options for running the tests
* XML test report generation

Базовые концепции

![](resources/gtest_concepts.png)

* Каждый тест реализован как функция, с использованием макроса TEST() или TEST_F().
* TEST() не только определяет, но и "регистрирует" тест.

Полезные советы
* Тесты можно временно выключать
* Тесты можно фильтровать по имени при запуске
* У Google Test есть ряд других полезных опций

Приложение: Порядок использования Google Test

* Начальная стадия

1. Скомпилировать Google Test в библиотеку.
2. Создать новое консольное приложение (test suite)\ и прилинковать к нему библиотеку Google Test.
3. Добавить тесты.
4. Скомпилировать приложение с тестами и запустить его.

* Основная стадия

1. Новые тесты добавляются в тот же test suite, их могут быть тысячи.
2. При необходимости test suite разбивается на несколько
3. Корректность и производительность
4. Быстрый (pre-commit) и полный (ночной)













