#### 1.1. Сравнительный анализ текстового и бинарного форматов.
#### 1.2. Тестирование. Классификация тестов, критерии хорошего теста, инструменты.

#### 2.1. Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.
#### 2.2. Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.

#### 3.1. Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.
#### 3.2. Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

#### 4.1. Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования.
#### 4.2. Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем.

#### 5.1. СКВ. Основные функции и термины, базовые принципы.
#### 5.2. Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации.

#### 6.1. Git (назначение, возможности, преимущества) и GitHub flow.

Git Flow:
![](resources/git-flow.png)

#### 6.2. Бинарные модули. Внутренняя структура ELF и PE модулей.

#### 7.1. Автоматизация. Преимущества, способы реализации, примеры.
#### 7.2. Отладка. Назначение, методы, алгоритм "волчья ограда".

#### 8.1. Markdown. Назначение, синтаксис, примеры использования.
#### 8.2. ИСР. Назначение, состав, возможности.

#### 9.1. Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов.
#### 9.2. Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

#### 10.1. История развития билд-систем (от shell до CMake и IDE).
#####Shell-скрипт

Программа, выполняемая командной оболочкой операционной системы. Пишется скрипт, в котором указываются команды сборки файлов программы.

Плюсы:
- Не нужно компилировать
- Присутствует на различных платформах (Linux - .sh, Windows - .bat)
- Нужно знать только команды консоли

Минусы:
- Не запрограммируешь сложную логику сборки

#####Make (1977)

Утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка в исполняемые файлы или библиотеки.

Программа make выполняет команды согласно правилам, указанным в Makefile.

Синтаксис Makefile:
```
цель1 цель2 ...: реквизит1 реквизит2 ...
        команда1
        команда2
        ...
```

Пример Makefile:
```
program: main.o lib.o
        cc -o program main.o lib.o
```

#####Autotools

Это набор программных средств, предназначенных для поддержки переносимости исходного кода программ между UNIX-подобными системами. Включает в себя Autoconf, Automake и др.

- **Makefile.am** - Automake читает эти файлы и создает переносимый Makefile.am, которые после обработки скриптом конфигурации становится Makefile и используется make
- **Configure.ac** - Autoconf читает эти файлы и генерирует скрипт настройки configure. Скрипт запускается пользователем. Он читает файлы с расширением .in, обрабатывает их и в конечном результате получает Makefile.

Плюсы:
- Был де-факто стандартом и до сих пор используется

Минусы:
- Сложный
- Только Unix
- Зависимости

#####Cmake

Это кроссплатформенная система автоматизации сборки программного обеспечения из исходного кода. CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления сборкой из файлов CMakeLists.txt

Плюсы:
- Удобен после непродолжительного обучения
- Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или простой текстовый редактор)
- Обеспечивает переносимость и является стандартом де-факто для кроссплатформенных С++ проектов


Минусы:
- "Собственный" язык
- Поначалу кажется нетривиальным

-----
#####IDE

> __Интегрированная среда разработки, ИСР__ (англ. __IDE, Integrated development
> environment__ или __integrated debugging environment__) — система программных
> средств, используемая программистами для разработки программного обеспечения.

###### Функции современных IDE

  - Автодополнение кода
  - Поддержка шаблонов проектов
  - Сниппеты
  - Поддержка систем контроля версий
  - Интеграция задач (`//TODO: ...`)
  - Браузер классов
  - Визульное редактирование классов
  - Инструменты рефакторинга
  - Профилировщик
  - Работа с СУБД, веб-сервисами

#### 10.2. UNIX. Философия и преимущества при автоматизации.
This is the Unix philosophy:
- Write programs that do one thing and do it well.
- Write programs to work together.
- Write programs to handle text streams, because that is a universal interface.

#####Преимущества автоматизации
  - Мощность / повышение уровня абстракции
    - Фокус на основной задаче
    - Меньшее количество переключений контекста
  - Надежность
    - Отсутствие человеческого фактора
  - Скорость
  - Дешевизна
    - Особенно при многократном запуске
  - Освобождение времени

#####Классы задач на автоматизацию
  - Сбор и обработка данных
    - Составление отчетов/графиков, анализ и обработка больших массивов данных
  - Тестирование
    - Изменения ничего не сломали, анализ производительности
  - Администрирование
    - Регулярные процедуры (бэкап), сложное конфигурирование
  - Собственно автоматизация
    - Построение дистрибутивов, развертывание

#####Преимущества Unix при автоматизации
  - Огромное количество утилит на любой случай жизни
    - find, cron, tar, sed, etc.
  - Вместе со скриптовыми языками (Bash, Perl, Python, etc) предоставляет широчайшие возможности для автоматизации

#### 11.1. Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
#### 11.2. Статическая и динамическая компоновка. Сравнительный анализ.

#### 12.1. СКВ. Определение, назначение, история развития (преимущества DVCS).

> __Системы контроля версий__ — это программные системы, хранящие несколько
версий одного документа, и позволяющие вернуться к более ранним версиям. Как
правило, для каждого изменения запоминается дата модификации и автор.

История развития:
- Локальные
  - Примеры: RCS, SCCS
  - Организация одновременной работы: locks
- Централизованные
  - Примеры: Subversion, CVS
  - Организация одновременной работы: merge before commit
- Распределенные
  - Примеры: Git, Mercurial
  - Организация одновременной работы: commit before merge

Назначение:
- Системы контроля версий — центральный инструмент разработки
 - Навигация по истории изменений
 - Централизованный доступ
- Имеются и другие применения:
 - Конфигурации, документация, компьютерная анимация, САПР и др.
 - Появляется все больше примеров использования в других отраслях
   ([книгоиздание](https://github.com/certik/theoretical-physics), [государственные документы](http://www.youtube.com/watch?v=CEN4XNth61o)).

Распределенные СКВ фактически стали стандартом. Их сильные стороны:
- Допускают локальные коммиты (без наличия интернет или доступа к серверу)
- Упрощают слияние (а значит параллельную разработку)
- Дают максимальную свободу по организации рабочего процесса (workflow)

#### 12.2. CMake. Назначение, возможности, плюсы и минусы.
Это кроссплатформенная система автоматизации сборки программного обеспечения из исходного кода. CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления сборкой из файлов CMakeLists.txt

Плюсы:
- Удобен после непродолжительного обучения
- Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или простой текстовый редактор)
- Обеспечивает переносимость и является стандартом де-факто для кроссплатформенных С++ проектов

Минусы:
- "Собственный" язык
- Поначалу кажется нетривиальным

__Возможности__:
Указание необходимой версии cmake. Писать эту команду всегда - хороший стиль

    cmake_minimum_required(VERSION 2.6)

Название проекта. Указывает, что этот cmake-файл является корневым для некоторого проекта.

    project(visualization)

Переменные

    set(VARIABLE The variable's value)

Команды компилятору

    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall")

Подключение библиотек

    set(Boost_USE_STATIC_LIBS OFF)
    set(Boost_USE_MULTITHREADED ON)

Подключение заголовков

    include_directories("headers/" "more_headers/")

#### 13.1. Современная стратегия тестирования (включая распределение ролей и инструментальную поддержку).

- Без "зеленых" тестов нет уверенности в работоспособности кода
 - Фокус на максимальную автоматизацию
 - Полное тестирование требуется несколько раз в день, каждому члену команды
- __Тесты пишутся самими разработчиками, одновременно с реализацией__
 - Тесты это лучшая документация, которая всегда актуальна (компилятор!)
 - Тесты это первые сэмплы, показывающие простые примеры использования
 - Test-Driven Development
- Код тестируется __непрерывно__
 - Это делается локально на машине разработчика
 - Это делается на сервере до того, как добавить его в репозиторий
- Автоматические тесты замещают отладку
 - Предсказуемость времени разработки
 - __Пойманный баг документируется в виде теста__


Возможности фреймворков модульного тестирования:
1. Удобное добавление тестов
 - Простая регистрация новых тестов
 - Набор функций-проверок (`assert`)
 - Общие инициализации и деинициализации
1. Удобный запуск тестов
 - Пакетный режим
 - Возможность фильтрации тестов по именам
1. Часто допускают интеграцию с IDE
1. Генерация отчета в стандартном XML-формате
 - Возможность последующего автоматического анализа
 - Публикация на web-страницах проекта

#### 13.2. Метапрограммирование. Определение и примеры.

> Метапрограммирование — вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы.

Примеры:
- Шаблоны в С++
- Cog (генератор кода общего назначения)
- lex & yacc
 - Lex - лексический анализатор, позволяет осуществлять разбор входной последовательности символов с целью получения на выходе последовательности символов, называемых токенами.
 - Yacc - синтаксический анализатор, который позволяет сопоставить линейной последовательности токенов языка его формальную грамматику.


#### - Оптимизиция. Назначение, критерии оптимизации, порядок.
#### - Профилировка. Назначение, возможности, использование.
